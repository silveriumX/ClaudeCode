# Git и GitHub: пошаговое обучение до уверенного пользователя

> Один репозиторий Cursor: личное + рабочее, часть проектов — с шарингом. Теория, нюансы и практика в твоих реальных проектах.

**Дата:** 10.02.2026
**Связанные документы:** [INDEX.md](INDEX.md), [COMMANDS_CHEATSHEET.md](COMMANDS_CHEATSHEET.md), [Git_и_GitHub_в_Cursor.md](../Cursor/Git_и_GitHub_в_Cursor.md)

---

## Как пользоваться этим файлом

- **Теория** — коротко: что это и зачем.
- **Нюансы** — типичные подводные камни и «кнопки» в Cursor/GitHub.
- **Практика** — задания в твоём репозитории; делай по порядку.
- Чекбоксы `[ ]` — отмечай выполнение.

В конце каждого модуля — мини-чеклист «понимаю ли я это».

---

# Модуль 1: Что такое Git и зачем он тебе

## 1.1 Идея Git в двух словах

**Git** — это система версий: хранит историю изменений файлов и позволяет в любой момент откатиться, сравнить версии или параллельно вести несколько линий разработки (ветки).

**Зачем в твоём случае:**
- Один репозиторий Cursor: и личные задачи (`Work/Задачи/`, `Личное1/`), и рабочие (`Projects/`).
- Бэкап на GitHub — ничего не теряется при поломке ПК.
- Шаринг рабочих проектов — даёшь доступ коллегам к репо или к отдельным папкам через один репо; изменения собираются через ветки и Pull Request’ы.

**Git ≠ GitHub.** Git — программа и формат данных (локально). GitHub — сайт и сервис: хранит копию репозитория в облаке, даёт веб-интерфейс, PR, Issues, доступ по логину.

## 1.2 Три «слоя» файлов в Git

| Слой | Где | Что значит |
|------|-----|------------|
| **Рабочая копия** | Файлы на диске в `Documents\Cursor` | То, что ты редактируешь в Cursor. Git «видит» изменения, но ещё не сохранил их в историю. |
| **Staging (индекс)** | Внутри `.git` | Файлы, которые ты *отметил* для следующего коммита (`git add`). Можно добавить не всё, а выборочно. |
| **История (коммиты)** | Внутри `.git` | Сохранённые снимки. После `git commit` изменения попадают в историю и получают уникальный хеш. |

**Нюанс:** без `git add` коммит не увидит изменения. В Cursor это кнопка «+» у файла в Source Control или «Stage All Changes».

## 1.3 Практика 1.1: Убедиться, что Git настроен

**Задание:**

1. Открой терминал в корне репозитория (например, Cursor: Terminal → New Terminal).
2. Выполни и запомни вывод:

```powershell
cd C:\Users\Admin\Documents\Cursor

git --version
git status
git remote -v
git config user.name
git config user.email
```

- `git --version` — установлен ли Git.
- `git status` — какие файлы изменены/не в индексе.
- `git remote -v` — куда делается `push` (твой GitHub).
- `user.name` и `user.email` — подписывают коммиты (важно для шаринга и истории).

**Проверь:** в `git remote -v` должен быть твой репозиторий (например `origin  https://github.com/silveriumX/Cloud_Cursor.git`).

- [ ] Выполнил команды и понял, что каждая показывает.

---

# Модуль 2: Ежедневный цикл — коммит, push, pull

## 2.1 Базовый цикл

1. Ты меняешь файлы (рабочая копия).
2. `git add` (или «+» в Cursor) — переносишь изменения в staging.
3. `git commit -m "описание"` — сохраняешь снимок в историю (локально).
4. `git push` — отправляешь коммиты на GitHub.

**Pull** — «скачать» коммиты с GitHub и влить их в текущую ветку. Нужен, когда работаешь с другого ПК или когда кто-то ещё пушит в тот же репо.

## 2.2 Где что в Cursor

- **Source Control:** `Ctrl+Shift+G`. Список изменённых файлов, diff, Stage (+), поле сообщения коммита, кнопка Commit.
- **Статус-бар внизу:** имя ветки, `*` — есть несохранённые/незакоммиченные изменения, `↑N` — N коммитов не запушено, `↓N` — N коммитов на сервере, которых у тебя нет.
- **Git Graph (если установлен):** граф коммитов и веток, Push/Pull/Fetch, Reset.

Подробнее: [Git_и_GitHub_в_Cursor.md](../Cursor/Git_и_GitHub_в_Cursor.md).

## 2.3 Нюансы

- **Коммитить лучше часто и маленькими порциями** — проще откатить и понять историю.
- **Сообщение коммита** — коротко «что сделано», можно на русском или по формату `feat:`, `fix:` (см. [COMMANDS_CHEATSHEET.md](COMMANDS_CHEATSHEET.md)).
- **Push после работы** — иначе на другом устройстве или у коллег не будет твоих изменений.

## 2.4 Практика 2.1: Один полный цикл (локально + push)

**Задание:**

1. Создай учебный файл в документации:
   - Путь: `Documentation/GitHub/GIT_OBUCHENIE_PRAKTICA.md`
   - Содержимое: одна строка, например «Практика 2.1 — первый коммит» и дата.
2. В Source Control (`Ctrl+Shift+G`):
   - Убедись, что файл в списке изменений.
   - Нажми «+» у файла (Stage).
   - Введи сообщение: `docs: add GIT_OBUCHENIE_PRAKTICA for Module 2`.
   - Нажми Commit (галочка).
3. В статус-баре должно появиться `↑1`. Нажми Sync (или Push) и отправь на GitHub.
4. Зайди на GitHub в браузере — в репозитории должен появиться этот файл и новый коммит.

- [ ] Создал файл, застейджил, закоммитил, запушил.
- [ ] Увидел коммит на GitHub.

## 2.5 Практика 2.2: Pull (симуляция «пришли изменения с сервера»)

**Задание:**

1. На GitHub в браузере открой любой файл (например `README.md`), нажми Edit, добавь строку в конец (например `<!-- test pull -->`), закоммить через интерфейс (Commit changes).
2. В Cursor в статус-баре должно появиться `↓1`. Нажми Sync (или Pull).
3. Убедись, что локальный файл обновился (появилась твоя строка).

- [ ] Сделал изменение на GitHub и подтянул его через Pull в Cursor.

---

# Модуль 3: .gitignore и что не должно попадать в репозиторий

## 3.1 Зачем .gitignore

Файлы в `.gitignore` Git не отслеживает: они не попадут в коммиты и на GitHub. Это защита секретов и мусора.

**В твоём репо уже есть:** `.env`, `*service*account*.json`, `CREDENTIALS.md`, личные папки и т.д. — см. корневой `.gitignore`.

## 3.2 Как это работает

- Git смотрит на пути относительно корня репо. Строка в `.gitignore` — это шаблон (поддержка `*`, `**/` и т.д.).
- Если файл **уже был закоммичен**, добавление в `.gitignore` не удалит его из истории — нужно отдельно убрать из индекса: `git rm --cached путь/к/файлу`.

## 3.3 Нюансы для «личное + рабочее»

- Личные заметки/разборы можно держать в папках, которые в `.gitignore` (например `Личное/`, `Personal/`), тогда они не уйдут при шаринге репо.
- Секреты (токены, ключи, пароли) — только в игноре и в локальных файлах; коллегам давать шаблон (например `.env.example`, `CREDENTIALS.example.md`).

## 3.4 Практика 3.1: Проверить .gitignore и один «игнор»

**Задание:**

1. Открой `C:\Users\Admin\Documents\Cursor\.gitignore`. Найди блок с credentials и блок с личными папками.
2. Проверь: выполни в корне репо `git status`. Убедись, что файлы типа `.env` или личных папок не показываются в Changes.
3. (Опционально.) Добавь в `.gitignore` одну строку для теста, например `GIT_OBUCHENIE_PRAKTICA_LOCAL.md`. Создай такой файл в корне. Убедись, что он не появляется в Source Control.

- [ ] Понял, какие данные защищены через .gitignore.
- [ ] Проверил, что секреты/личное не в списке изменений.

---

# Модуль 4: Ветки (branch) — зачем и когда

## 4.1 Что такое ветка

**Ветка** — это отдельная линия коммитов. По умолчанию обычно есть ветка `main` (или `master`). Новые коммиты «наращивают» текущую ветку. Можно создать другую ветку и коммитить туда — история разойдётся, потом её можно слить (merge).

**Зачем в твоём сценарии:**
- **Личное:** эксперимент или крупное изменение — делаешь в отдельной ветке; если не понравится, просто вернуться на `main`.
- **Шаринг с людьми:** коллеги делают ветки (например `feature/название`), ты смотришь изменения и вливаешь в `main` через Pull Request — так не ломается общая линия.

## 4.2 Основные команды

- `git branch` — список локальных веток, `*` — текущая.
- `git branch -a` — все ветки, включая удалённые (`remotes/origin/...`).
- `git checkout -b имя-ветки` — создать ветку и переключиться на неё.
- `git checkout имя-ветки` — переключиться на существующую ветку.
- После merge ветки можно удалить: `git branch -d имя-ветки`.

**В Cursor:** переключение ветки — в статус-баре по клику на имя ветки или в Git Graph.

## 4.3 Нюансы

- Переключиться на другую ветку можно только с «чистым» деревом (все изменения закоммичены или спрятаны в stash). Иначе Git предупредит.
- `git push -u origin имя-ветки` — первый раз отправить новую ветку на GitHub; дальше достаточно `git push`.

## 4.4 Практика 4.1: Ветка для эксперимента

**Задание:**

1. Убедись, что все изменения закоммичены (`git status` чистый).
2. Создай ветку и переключись: `git checkout -b docs/git-learning`.
3. В этой ветке создай или измени файл `Documentation/GitHub/GIT_OBUCHENIE_PRAKTICA.md` — добавь раздел «Практика 4.1» и одну строку.
4. Закоммить и отправить ветку:
   `git add ...` → `git commit -m "docs: practice branch in git learning"` → `git push -u origin docs/git-learning`.
5. На GitHub открой репозиторий — в выпадающем списке веток должна быть `docs/git-learning`.
6. В Cursor переключись обратно на `main`: `git checkout main`. Убедись, что изменения из ветки в `main` не видны (их там ещё нет).
7. (Позже, после модуля про merge/PR.) Либо смержишь эту ветку в `main`, либо удалишь — как захочешь.

- [ ] Создал ветку, сделал коммит в ней, запушил и увидел её на GitHub.
- [ ] Понял, что на `main` этих изменений нет, пока не смержить.

---

# Модуль 5: Конфликты и их решение

## 5.1 Когда бывают конфликты

Конфликт возникает, когда Git не может сам объединить изменения: одна и та же часть файла изменена в двух «историях» (например в `main` и в твоей ветке после pull, или у тебя и у коллеги в одном файле).

Типично при:
- `git pull` и у тебя есть локальные коммиты в том же файле;
- `git merge другая-ветка` и в обеих ветках меняли одни строки.

## 5.2 Как выглядят конфликты

В файле появятся маркеры:

```
<<<<<<< HEAD
твой вариант (или текущая ветка)
=======
вариант из входящих изменений
>>>>>>> origin/main
```

Нужно оставить нужный вариант (или объединить оба), удалить строки с `<<<<<<<`, `=======`, `>>>>>>>`, сохранить файл, затем:

```powershell
git add путь/к/файлу
git commit -m "merge: resolve conflict in ..."
```

## 5.3 Нюансы

- Не паниковать: конфликт — нормально при совместной работе. Решается правкой файла.
- После разрешения конфликта обязательно сделать `git add` и `git commit` (merge-коммит).
- В Cursor при конфликте файл подсвечивается; можно использовать «Accept Current / Incoming / Both» в diff, но понимание маркеров полезно.

## 5.4 Практика 5.1: Специально вызвать и решить конфликт

**Задание (лучше в отдельной ветке или копии, чтобы не портить основную):**

1. Создай ветку: `git checkout -b docs/conflict-practice`.
2. В `Documentation/GitHub/GIT_OBUCHENIE_PRAKTICA.md` в одной и той же строке (например в начале) напиши: `Version A`.
3. Закоммить и запушить: `git add ...`, `git commit -m "conflict practice A"`, `git push -u origin docs/conflict-practice`.
4. На GitHub открой этот файл в ветке `docs/conflict-practice`, измени ту же строку на `Version B` и закоммить через веб-интерфейс.
5. Локально в той же строке измени на `Version C`, сохрани.
6. Сделай `git add`, `git commit -m "conflict practice C"`, затем `git pull origin docs/conflict-practice`. С высокой вероятностью получишь конфликт.
7. Открой файл, найди маркеры, оставь один вариант (или объедини текст), удали маркеры, сохрани.
8. Выполни `git add Documentation/GitHub/GIT_OBUCHENIE_PRAKTICA.md`, `git commit -m "merge: resolve conflict practice"`, `git push`.

- [ ] Осознанно получил конфликт и разрешил его через правку файла и коммит.

---

# Модуль 6: GitHub — интерфейс и кнопки

## 6.1 Главные страницы репозитория

- **Code** — файлы и папки, список веток, клонирование (HTTPS/SSH).
- **Issues** — задачи, баги, обсуждения (не в коде).
- **Pull requests (PR)** — предложения влить ветку в другую (часто в `main`). Там же ревью и обсуждение.
- **Actions** — автоматические сценарии (сборки, тесты).
- **Settings** — имя репо, доступ (Collaborators), Branch protection, секреты.

## 6.2 Кнопки и действия на странице репо

- **Code → ветка** — переключение ветки, скачать ZIP.
- **Green "Code"** — URL для clone; HTTPS проще для начала (логин + токен).
- **Fork** — скопировать репо к себе (для открытых проектов и контрибьюта).
- **Star / Watch** — подписка на обновления.
- **Pull request** (когда есть новая ветка) — создать PR из этой ветки в выбранную (обычно `main`).
- В файле: **Edit (карандаш)** — правка в веб-интерфейсе с коммитом от твоего имени.
- **History** — история коммитов файла.
- **Blame** — кто и в каком коммите менял каждую строку.

## 6.3 Настройки доступа (для шаринга)

- **Settings → Collaborators** — добавить людей по логину GitHub; можно выдать роль (Read / Write / Admin). Write — могут пушить и создавать ветки/PR.
- **Settings → Branches → Branch protection** — правила для ветки (например `main`): запрет пуша напрямую, обязательный PR, ревью. Полезно для рабочих проектов.

## 6.4 Практика 6.1: Обойти репозиторий на GitHub

**Задание:**

1. Открой свой репозиторий на GitHub (тот же, что в `git remote -v`).
2. Переключи ветку в выпадающем списке (если есть `docs/git-learning` — открой её).
3. Зайди в любой файл в `Documentation/GitHub/`. Нажми **History** и посмотри последние коммиты.
4. Зайди в **Pull requests** — создан ли какой-то (например от твоей учебной ветки). Если да — открой и посмотри вкладки (Conversation, Files changed).
5. Зайди в **Settings** (если есть права). Посмотри **Collaborators** и **Branches** (branch protection). Не меняй пока ничего — просто запомни, где это.

- [ ] Нашёл Code, Issues, Pull requests, Settings.
- [ ] Посмотрел историю файла и структуру PR.

---

# Модуль 7: Pull Request (PR) — совместное принятие изменений

## 7.1 Что такое PR

**Pull Request** — предложение: «влить мою ветку в твою (обычно в `main`)». На GitHub открывается страница с diff, комментариями и кнопкой Merge. Пока ты не нажмёшь Merge, изменения из ветки в `main` не попадут.

**Зачем при шаринге:** коллега пушит в свою ветку, создаёт PR в `main`, ты смотришь изменения и принимаешь или просишь правки. Так основная ветка остаётся контролируемой.

## 7.2 Жизненный цикл PR

1. Кто-то пушит ветку на GitHub.
2. На странице репо появляется жёлтая полоска «Compare & pull request» (или заходишь в Pull requests → New).
3. Выбираешь: base — `main`, compare — ветка с изменениями. Пишешь описание.
4. Create pull request.
5. Ревью (опционально): комментарии к строкам кода.
6. Merge — выбор способа: Merge commit, Squash, Rebase. Для начала достаточно **Merge commit**.
7. После merge можно удалить ветку (кнопка Delete branch).

## 7.3 Нюансы

- Если в `main` появились новые коммиты после создания ветки, перед merge лучше обновить ветку (на GitHub можно нажать «Update branch» или локально: `git checkout ветка`, `git pull origin main`, `git merge main`, разрешить конфликты, `git push`).
- **Squash** — все коммиты ветки схлопнуть в один при merge. **Rebase** — переписать историю ветки поверх `main`; аккуратно использовать при уже запушенной ветке.

## 7.4 Практика 7.1: Создать и смержить свой PR

**Задание:**

1. Убедись, что у тебя есть ветка с коммитами (например `docs/git-learning` запушена).
2. На GitHub открой репозиторий, переключись на эту ветку. Нажми **Compare & pull request** (или Pull requests → New pull request; base: `main`, compare: твоя ветка).
3. Заполни заголовок и описание (например: «Учебный PR по модулю 7»). Create pull request.
4. Открой вкладку **Files changed** — посмотри diff.
5. Нажми **Merge pull request**, затем **Confirm merge**. При желании удали ветку (Delete branch).
6. Локально переключись на `main` и сделай `git pull`. Убедись, что изменения из ветки теперь в `main`.

- [ ] Создал PR, посмотрел diff и смержил.
- [ ] Подтянул обновлённый `main` локально.

---

# Модуль 8: Откаты и «спасательные» команды

## 8.1 Уровни отката

| Ситуация | Что сделать | Риск |
|----------|--------------|------|
| Изменил файл, не делал `add` | `git checkout -- путь/к/файлу` или `git restore путь/к/файлу` | Отмена только локальных правок в файле. |
| Сделал `add`, не делал `commit` | `git restore --staged путь/к/файлу` затем при необходимости `git restore путь/к/файлу` | Файл уходит из staging, правки в рабочей копии можно оставить или сбросить. |
| Сделал последний `commit`, ещё не пушил | `git reset --soft HEAD~1` — отменить коммит, оставить изменения в staging | Безопасно. |
| То же, но убрать и из staging | `git reset HEAD~1` (mixed) | Изменения останутся в рабочей копии. |
| То же, убрать и изменения в файлах | `git reset --hard HEAD~1` | **Опасно:** локальные изменения пропадут. |
| Уже запушил, хочешь «отменить» коммит | `git revert HEAD` затем `git push` | Безопасно: создаётся новый коммит, отменяющий последний. История не переписывается. |

## 8.2 Stash — временно «спрятать» изменения

Если нужно переключить ветку или сделать pull, а коммитить пока не хочешь:

```powershell
git stash
# переключился, сделал что нужно
git stash pop
```

`git stash list` — список stash’ей. `git stash pop` — применить последний и удалить его из списка.

## 8.3 Нюансы

- **Не делать `git push --force`** на общие ветки (например `main`) без договорённости — это перезаписывает историю на сервере и ломает других.
- Если случайно закоммитил секрет — сразу добавить файл в `.gitignore`, убрать из индекса (`git rm --cached ...`), закоммитить, и **обязательно сменить пароль/токен/ключ**, потому что старый уже мог попасть в историю.

## 8.4 Практика 8.1: Безопасный откат последнего коммита

**Задание:**

1. Создай тестовый файл (например в `Documentation/GitHub/`), закоммить и **не пушить**.
2. Выполни `git reset --soft HEAD~1`. Проверь: коммит исчез из истории (`git log --oneline -3`), но файлы остались в staging (Source Control).
3. Снова закоммить с нормальным сообщением и при желании запушить — или удалить файл и отменить через `git restore`, если он был только для практики.

- [ ] Понял разницу между `reset --soft` и откатом файла через `restore`.

---

# Модуль 9: Один репо — личное и рабочее, шаринг

## 9.1 Твоя схема

- **Один репозиторий** в папке Cursor: и личное (задачи, заметки), и рабочие проекты.
- **Личное** можно держать в папках/файлах, которые в `.gitignore`, тогда при шаринге репо коллеги их не увидят.
- **Шаринг:** даёшь доступ к репо (Collaborators) или делаешь отдельный репо только для рабочих проектов и синхронизируешь нужные папки — см. [WORKSPACE_OPTIONS.md](WORKSPACE_OPTIONS.md) и [TEAM_GITHUB_SETUP.md](TEAM_GITHUB_SETUP.md).

## 9.2 Правила, чтобы не путать контексты

- Всегда смотреть в Source Control, **в каком репо** ты коммитишь (если откроешь multi-root workspace с двумя папками — там будет два репо).
- Для рабочих изменений с коллегами: ветка → коммиты → push → PR в `main`. В `main` не пушить сырые эксперименты.
- Секреты и личное — только в игноре; коллегам — README и примеры (.env.example, CREDENTIALS.example.md).

## 9.3 Практика 9.1: Чеклист перед первым шарингом

**Задание (чеклист):**

- [ ] В `.gitignore` внесены все папки/файлы с личными данными и секретами.
- [ ] Проверил `git status` — нет случайно добавленных `.env`, ключей, личных заметок.
- [ ] На GitHub в Settings → Collaborators знаю, кого добавлять и с какой ролью.
- [ ] Решил, будет ли branch protection на `main` (рекомендуется для командного репо).
- [ ] Есть короткий README или CREDENTIALS.example с инструкцией «как запустить у себя».

---

# Итоговый чеклист «понимаю ли я»

Отметь, когда будешь уверен в пункте:

- [ ] Понимаю три слоя: рабочая копия, staging, коммиты.
- [ ] Умею делать цикл: правка → add → commit → push и pull в Cursor и в терминале.
- [ ] Понимаю, зачем .gitignore и что не должно попадать в репо при шаринге.
- [ ] Умею создавать ветку, коммитить в неё, пушить и переключаться между ветками.
- [ ] Понимаю, когда бывают конфликты и как их решать (маркеры + add + commit).
- [ ] Знаю основные кнопки и разделы на GitHub (Code, PR, Settings, Collaborators, Branches).
- [ ] Умею создать PR и смержить его в `main`.
- [ ] Знаю, как откатить последний коммит (reset --soft) и когда использовать revert.
- [ ] Понимаю разницу между личным и общим в одном репо и что проверять перед шарингом.

---

# Куда идти дальше

- **Шпаргалка команд:** [COMMANDS_CHEATSHEET.md](COMMANDS_CHEATSHEET.md)
- **Git в Cursor (кнопки, статус-бар):** [Git_и_GitHub_в_Cursor.md](../Cursor/Git_и_GitHub_в_Cursor.md)
- **Командная настройка и workflow:** [QUICK_START_TEAM.md](QUICK_START_TEAM.md), [TEAM_GITHUB_SETUP.md](TEAM_GITHUB_SETUP.md)
- **Варианты workspace (личное + командное):** [WORKSPACE_OPTIONS.md](WORKSPACE_OPTIONS.md)

После прохождения всех модулей и практик ты будешь уверенно пользоваться Git и GitHub в сценарии «один Cursor — личное и рабочее, с возможностью шарить проекты».
