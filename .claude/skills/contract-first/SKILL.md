# /contract-first — Contract-first разработка функций

Перед написанием функции с побочными эффектами — сначала зафиксировать контракт.
Предотвращает баги типа "а что вообще здесь должно происходить?".

## Когда применять

Автоматически (без вызова) для ЛЮБОЙ функции которая:
- Пишет в базу данных / Google Sheets / файл
- Меняет состояние (отправляет уведомление, обновляет статус)
- Вызывает внешний API с мутирующим эффектом

По запросу: "контракт", "/contract-first", "что меняет эта функция"

## Алгоритм: 3 вопроса перед кодом

### Вопрос 1: Что именно меняется?
Какие ячейки, строки, поля, файлы изменяются?

Пример ответа:
> Очищается ячейка роли (колонка D) для строки с нужным TID.
> Строка НЕ удаляется.

### Вопрос 2: Что НЕ меняется? (инварианты)
Что должно остаться нетронутым при любом исходе?

Пример ответа:
> ID, имя, username пользователя остаются.
> Другие пользователи не затрагиваются.
> delete_rows() НЕ вызывается никогда.

### Вопрос 3: Что возвращается при ошибке/отсутствии объекта?
False? None? Исключение? Пустой список?

Пример ответа:
> Если TID не найден → False (не исключение).
> Если лист недоступен → False (не исключение).

## Формат docstring (Side effects / Invariants)

```python
def deactivate_user(self, telegram_id: int) -> bool:
    """
    Деактивировать пользователя — очистить ячейку роли.

    Args:
        telegram_id: Telegram ID пользователя.

    Returns:
        True если деактивирован, False если не найден или лист недоступен.

    Side effects:
        - users_sheet.update_cell(row, 4, "") — очищает роль.
        - Строка пользователя остаётся в таблице (ADR-001).

    Invariants:
        - delete_rows() НЕ вызывается.
        - Другие пользователи не затрагиваются.
        - При False — никаких изменений в таблице.
    """
```

## Правила

- **Сначала docstring, потом код** — если не можешь написать контракт, значит недостаточно
  понял задачу. Уточни у пользователя.
- **Side effects** — только реальные изменения внешнего состояния. Не логирование.
- **Invariants** — то, что НИКОГДА не должно произойти. Особенно важно написать явный
  запрет ("delete_rows НЕ вызывается") — это лучшая документация решения.
- **ADR-ссылка** — если было архитектурное решение, ссылаться на него в docstring.

## Пример применения

**Плохо (без контракта):**
```python
def update_status(self, request_id, status):
    # находим строку и обновляем
    row = self._find_row(request_id)
    self.sheet.update_cell(row, 5, status)
    return True
```

**Хорошо (с контрактом):**
```python
def update_status(self, request_id: int, status: str) -> bool:
    """
    Обновить статус заявки.

    Args:
        request_id: ID заявки в таблице.
        status: Новый статус (одно из config.REQUEST_STATUSES).

    Returns:
        True если обновлено, False если заявка не найдена.

    Side effects:
        - requests_sheet.update_cell(row, 5, status).
        - Только колонка "Статус". Остальные поля не трогаются.

    Invariants:
        - Строка заявки не удаляется.
        - При False — никаких изменений в таблице.

    Preconditions:
        - status должен быть из допустимых значений (не валидируется — на совести вызывающего).
    """
    row = self._find_row(request_id)
    if row is None:
        return False
    self.sheet.update_cell(row, 5, status)
    return True
```

## Связь с ADR

Если принято нетривиальное решение (например, "не удалять строку, а очищать роль") —
создать `docs/decisions/ADR-NNN-название.md` по формату:

```markdown
# ADR-NNN: Название

## Статус
Принято (ГГГГ-ММ-ДД)

## Контекст
Что нужно было решить, какие варианты были.

## Решение
Какой вариант выбрали и почему.

## Последствия
Плюсы и минусы решения.
```
